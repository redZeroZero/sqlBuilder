package org.in.media.res.sqlBuilder.processor;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.MirroredTypeException;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;

import org.in.media.res.sqlBuilder.api.model.annotation.SqlColumn;
import org.in.media.res.sqlBuilder.api.model.annotation.SqlTable;

@SupportedAnnotationTypes("org.in.media.res.sqlBuilder.api.model.annotation.SqlTable")
@SupportedSourceVersion(SourceVersion.RELEASE_21)
public class SqlTableProcessor extends AbstractProcessor {

	private Filer filer;
	private Messager messager;
	private Elements elementUtils;

	@Override
	public synchronized void init(ProcessingEnvironment processingEnv) {
		super.init(processingEnv);
		this.filer = processingEnv.getFiler();
		this.messager = processingEnv.getMessager();
		this.elementUtils = processingEnv.getElementUtils();
	}

	@Override
	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
		for (Element element : roundEnv.getElementsAnnotatedWith(SqlTable.class)) {
			if (!(element instanceof TypeElement typeElement)) {
				continue;
			}
			generateArtifacts(typeElement);
		}
		return false;
	}

	private void generateArtifacts(TypeElement tableType) {
		String packageName = elementUtils.getPackageOf(tableType).getQualifiedName().toString();
		String simpleName = tableType.getSimpleName().toString();
		String interfaceName = simpleName + "Columns";

		List<ColumnDescriptor> columns = collectColumns(tableType);
		if (columns.isEmpty()) {
			return;
		}

		generateInterface(tableType, packageName, interfaceName, columns);
		generateImplementation(tableType, packageName, interfaceName, columns);
	}

	private void generateInterface(TypeElement tableType, String packageName, String interfaceName,
			List<ColumnDescriptor> columns) {
		StringBuilder source = new StringBuilder();
		source.append("package ").append(packageName).append(";\n\n");
		source.append("import org.in.media.res.sqlBuilder.core.model.ColumnRef;\n");
		source.append("import org.in.media.res.sqlBuilder.core.model.TableFacets;\n\n");
		source.append("/** Automatically generated by SqlTableProcessor. */\n");
		source.append("public interface ").append(interfaceName).append(" {\n");
		for (ColumnDescriptor column : columns) {
			source.append("\tColumnRef<").append(column.javaType()).append("> ").append(column.methodName())
					.append("();\n");
		}
		source.append("\n\tstatic ").append(interfaceName).append(" of(TableFacets.Facet facet) {\n");
		source.append("\t\treturn new ").append(interfaceName).append("Impl(facet);\n");
		source.append("\t}\n");
		source.append("}\n");
		writeSource(packageName + "." + interfaceName, source.toString(), tableType);
	}

	private void generateImplementation(TypeElement tableType, String packageName, String interfaceName,
			List<ColumnDescriptor> columns) {
		String className = interfaceName + "Impl";
		StringBuilder source = new StringBuilder();
		source.append("package ").append(packageName).append(";\n\n");
		source.append("import java.util.Objects;\n");
		source.append("import org.in.media.res.sqlBuilder.core.model.ColumnRef;\n");
		source.append("import org.in.media.res.sqlBuilder.core.model.TableFacets;\n\n");
		source.append("/** Automatically generated by SqlTableProcessor. */\n");
		source.append("public final class ").append(className).append(" implements ").append(interfaceName).append(" {\n");
		source.append("\tprivate final TableFacets.Facet facet;\n");
		for (ColumnDescriptor column : columns) {
			source.append("\tprivate ColumnRef<").append(column.javaType()).append("> ")
					.append(column.cacheField()).append(";\n");
		}
		source.append("\n\tpublic ").append(className).append("(TableFacets.Facet facet) {\n");
		source.append("\t\tthis.facet = Objects.requireNonNull(facet, \"facet\");\n");
		source.append("\t}\n\n");
		for (ColumnDescriptor column : columns) {
			source.append("\t@Override\n");
			source.append("\tpublic ColumnRef<").append(column.javaType()).append("> ")
					.append(column.methodName()).append("() {\n");
			source.append("\t\tif (").append(column.cacheField()).append(" == null) {\n");
			source.append("\t\t\t").append(column.cacheField()).append(" = cast(facet.column(\"")
					.append(column.lookupKey()).append("\"));\n");
			source.append("\t\t}\n");
			source.append("\t\treturn ").append(column.cacheField()).append(";\n");
			source.append("\t}\n\n");
		}
		source.append("\t@SuppressWarnings(\"unchecked\")\n");
		source.append("\tprivate static <T> ColumnRef<T> cast(ColumnRef<?> ref) {\n");
		source.append("\t\treturn (ColumnRef<T>) ref;\n");
		source.append("\t}\n");
		source.append("}\n");

		writeSource(packageName + "." + className, source.toString(), tableType);
	}

	private void writeSource(String className, String source, TypeElement originatingType) {
		try {
			JavaFileObject file = filer.createSourceFile(className, originatingType);
			try (Writer writer = file.openWriter()) {
				writer.write(source);
			}
		} catch (IOException ex) {
			messager.printMessage(Diagnostic.Kind.WARNING,
					"Unable to write generated source " + className + ": " + ex.getMessage(), originatingType);
		}
	}

	private List<ColumnDescriptor> collectColumns(TypeElement typeElement) {
		List<ColumnDescriptor> descriptors = new ArrayList<>();
		for (Element enclosed : typeElement.getEnclosedElements()) {
			if (!(enclosed instanceof VariableElement variable)) {
				continue;
			}
			SqlColumn sqlColumn = variable.getAnnotation(SqlColumn.class);
			if (sqlColumn == null) {
				continue;
			}
			if (!variable.getModifiers().contains(Modifier.STATIC)) {
				messager.printMessage(Diagnostic.Kind.WARNING,
						"@SqlColumn field must be static to participate in schema facets",
						variable);
				continue;
			}
			String methodName = variable.getSimpleName().toString();
			String lookupKey = methodName;
			String typeName = resolveType(variable, sqlColumn);
			descriptors.add(new ColumnDescriptor(methodName, lookupKey, typeName));
		}
		return descriptors;
	}

	private String resolveType(VariableElement variable, SqlColumn column) {
		String annotationType = extractTypeName(column);
		if (annotationType != null && !"java.lang.Object".equals(annotationType)) {
			return annotationType;
		}
		return variable.asType().toString();
	}

	private String extractTypeName(SqlColumn column) {
		try {
			Class<?> clazz = column.javaType();
			return clazz == Object.class ? null : clazz.getCanonicalName();
		} catch (MirroredTypeException ex) {
			TypeMirror mirror = ex.getTypeMirror();
			String typeName = mirror.toString();
			return "java.lang.Object".equals(typeName) ? null : typeName;
		}
	}

	private record ColumnDescriptor(String methodName, String lookupKey, String javaType) {
		String cacheField() {
			return "cached_" + methodName().toUpperCase(Locale.ROOT);
		}
	}
}
